<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jungwoo Kim</title>
  <link href="https://github.com/borkdude/quickblog/atom.xml" rel="self"/>
  <link href="https://github.com/borkdude/quickblog"/>
  <updated>2024-07-21T10:53:08+00:00</updated>
  <id>https://github.com/borkdude/quickblog</id>
  <author>
    <name>Quick Blogger</name>
  </author>
  <entry>
    <id>https://github.com/borkdude/quickblog/2023-03-25-stackoverflow_2022_survey.html</id>
    <link href="https://github.com/borkdude/quickblog/2023-03-25-stackoverflow_2022_survey.html"/>
    <title>2022 stackoverflow survey</title>
    <updated>2023-03-25T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>2022년 스택오버플로우 설문 조사 결과</p><p>개발자 프로필부터, 프로그래밍 기술(Language, Database, Tool 등), 커뮤니티 등등 아주 많은 범위에서 나온 결과.</p><p><a href='https://survey.stackoverflow.co/2022/#top-paying-technologies'>Top paying tech</a> Clojure 개발자가 무려 1등! 상위 언어들은 함수형 언어(F#, Scala, Elixir, OCaml)도 보이고 Rust, Go 같은 동시성이나 안정성, 퍼포먼스와 관련되어 강조된 언어도 보인다. 언어는 표현수단일 뿐이지만, 그래도 개발자들한테 흥미로운 자극을 주는 것은 사실.</p><p><a href='https://survey.stackoverflow.co/2022/#programming-scripting-and-markup-languages'>Loved vs Dreaded Programming</a> Rust, Elixir, Clojure. 올해엔 Elixir를 꼭 사용해봐야겠다.</p><p><a href='https://survey.stackoverflow.co/2022/#web-frameworks-and-technologies'>Loved Dreaded Web Frameworks</a> 앞의 내용과 비슷하게 올해엔 Elixir와 함께 Pheonix를 사용해볼 일이 있으면 좋겠다. 그리고 재밌는 건, Clojure는 프레임워크라는게 없기(?) 때문에 데이터가 없는데 뭔가 당연하기도 하고 다행이다 싶다. Frameworks은 Frame에 맞게 Works를 하는 것이기 때문에...</p><p>재미로 읽는 설문조사이긴 하지만, 여기 나온 조사의 결과들과 한국에서의 인기는 상관관계가 없는 것 같다. 한편으로 아쉽기도 하고 이게 현실인 것을 뭐 어쩌하리.</p><p>개인 프로젝트에 사용하거나, 회사에서 스터디를 통해 장점을 알아가는 방법을 찾아야할 듯하다.</p>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2023-02-20-clojure-materials.html</id>
    <link href="https://github.com/borkdude/quickblog/2023-02-20-clojure-materials.html"/>
    <title>Clojure materials</title>
    <updated>2023-02-20T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<h2 id="videos">Videos</h2><ul><li><a href='https://www.youtube.com/watch?v=wASCH_gPnDw'>Inside Clojure</a></li><li><a href='https://www.youtube.com/watch?v=LKtk3HCgTa8&t=41s'>Simple Made Easy</a></li><li><a href='https://ericnormand.me/programmer-profiles/rich-hickey'>Rich Hickey's talks, interviews, and articles</a></li><li><a href='https://lambdaisland.com/blog/2022-04-25-making-lambda-island-free'>Clojure Free Courses from lambda island</a></li><li><a href='https://www.jacekschae.com/'>One of Clojure Course</a></li></ul><h2 id="reads">Reads</h2><ul><li><a href='https://chreke.com/little-languages.html'>Little Languages</a></li><li><a href='https://objectcomputing.com/resources/publications/sett/march-2009-clojure-functional-programming-for-the-jvm'>Basic Clojure</a></li><li><a href='https://gist.github.com/baumgardner/c147450a5bac9b955d9c'>Clojure is for type b personalities</a></li><li><a href='https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/'>Parse, don't validate</a></li><li><a href='https://guide.clojure.style/'>Clojure Style Guide</a></li><li><a href='https://shadow-cljs.github.io/docs/UsersGuide.html'>Shadow CLJS</a></li><li><a href='https://www.brainonfire.net/files/seqs-and-colls/main.html'>Collections and Sequences in Clojure</a></li></ul><h2 id="programming">Programming</h2><ul><li><a href='https://www.youtube.com/watch?v=8Ab3ArE8W3s'>"Stop Writing Dead Programs" by Jack Rusher</a></li><li><a href='https://medium.com/@metabase/why-we-picked-clojure-448bf759dc83'>Why we picked clojure from metabase</a></li><li><a href='https://www.youtube.com/watch?v=8pDqJVdNa44'>React.js</a></li><li><a href='https://roadmap.sh/backend'>Backend roadmap</a></li><li><a href='https://ericnormand.me/article/arguments-against-frameworks'>Arguments against frameworks</a></li></ul>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2022-10-11-Debugging_clojure_with_trace_and_portal.html</id>
    <link href="https://github.com/borkdude/quickblog/2022-10-11-Debugging_clojure_with_trace_and_portal.html"/>
    <title>Debugging Clojure with trace and portal</title>
    <updated>2022-10-11T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>Since I started with Debugging clojure, I have used to use <code>prn</code> to see results. I also used <code>#dbg</code> in calva, which looks like a traditional debug mode and good as well. However, I'd like to improve my debugging with REPL driven development and be more productive. I have searched for things and end up with finding nice combinations, <a href='trace'>trace</a> + <a href='portal'>portal</a>.</p><h2 id="prerequisite">Prerequisite</h2><p>Understanding <a href='tap'>tap></a></p><h2 id="trace">Trace</h2><p><a href='trace'>trace</a> is written by <a href='https://github.com/hlship'>hlship</a> and a README contains motivations. I find it strong to leave trace codes in production because the debug is traced when the set-up is on. The other point is it let us know where it is traced. If you experienced with <code>tap&gt;</code>, it's hard to trace a bunch of values in a tap.</p><h2 id="portal">Portal</h2><p>[portal] is written by <a href='https://github.com/djblue'>djblue</a>. It connects to REPL and can navitate data. Obviously, it's related with UI stuff and navigation tool.</p><h3 id="1._using_prn">1. Using prn</h3><p>Easy approach to debug.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn inspector
  &#91;x&#93;
  &#40;prn x&#41;
  x&#41;

&#40;defn calls
  &#91;&#93;
  &#40;inspector &quot;called&quot;&#41;&#41;

&#40;defn calls&gt;
  &#91;&#93;
  &#40;-&gt; {:value 1}
      &#40;update :value inc&#41;
      inspector
      &#40;assoc :after true&#41;&#41;&#41;

&#40;defn calls&gt;&gt;
  &#91;&#93;
  &#40;-&gt;&gt; &#40;range 10&#41;
       &#40;map inc&#41;
       inspector
       &#40;partition 2&#41;&#41;&#41;

&#40;comment
  &#40;calls&#41;
  ;; &quot;called&quot;
  &#40;calls&gt;&#41;
  ;; {:value 2}
  &#40;calls&gt;&gt;&#41;
  ;; &#40;1 2 3 4 5 6 7 8 9 10&#41;
  &#41;
</code></pre></p><h3 id="2._using_tap%3E">2. Using tap></h3><p><code>tap&gt;</code> is always good enough but a little bit hard to label.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;def debug-atom &#40;atom &#91;&#93;&#41;&#41;
&#40;add-tap &#40;fn &#91;value&#93; &#40;swap! debug-atom #&#40;conj % value&#41;&#41;&#41;&#41;

&#40;comment
  &#40;tap&gt; 1&#41;
  @debug-atom
  ;; &#91;1&#93;

  &#40;tap&gt; {:age  31
         :name &quot;jungwoo&quot;}&#41;
  @debug-atom&#41;
  ;; &#91;1 {:age  31
         :name &quot;jungwoo&quot;}&#93;
</code></pre></p><h3 id="3._using_trace">3. Using trace</h3><p>This sample code is from <a href='https://github.com/hlship/trace/blob/main/test/net/lewisship/trace_test.clj'>here</a>. I've forked this repo and changed just few line to make it easy threading macro.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn calls-trace
  &#91;&#93;
  &#40;trace :msg &quot;called&quot;&#41;&#41;

&#40;defn calls-trace&gt;
  &#91;&#93;
  &#40;-&gt; {:value 1}
      &#40;update :value inc&#41;
      &#40;trace&gt; :label :post-inc&#41;
      &#40;assoc :after true&#41;&#41;&#41;

&#40;defn calls-trace&gt;&gt;
  &#91;&#93;
  &#40;-&gt;&gt; &#40;range 10&#41;
       &#40;map inc&#41;
       &#40;trace&gt;&gt; :label :post-inc&#41;
       &#40;partition 2&#41;&#41;&#41;


&#40;comment
  &#40;calls-trace&#41;
;; no output
  &#40;trace/setup-default&#41;
;; Reload this NS to test the remainder:
  &#40;calls-trace&#41;
;;   {:in     my-only-trace/calls-trace
;;    :line   7
;;    :thread &quot;nREPL-session-90a76836-b2ce-4d07-86db-23db11474218&quot;
;;    :msg    &quot;called&quot;}
  &#40;calls-trace&gt;&#41;
;;   {:in      my-only-trace/calls-trace&gt;
;;    :line    13
;;    :thread  &quot;nREPL-session-90a76836-b2ce-4d07-86db-23db11474218&quot;
;;    :%value% {:value 2}
;;    :label   :post-inc}
  &#40;calls-trace&gt;&gt;&#41;
;;   {:in      my-only-trace/calls-trace&gt;&gt;
;;    :line    20
;;    :thread  &quot;nREPL-session-90a76836-b2ce-4d07-86db-23db11474218&quot;
;;    :%value% &#40;1 2 3 4 5 6 7 8 9 10&#41;
;;    :label   :post-inc}
  &#41;
</code></pre></p><h3 id="4._using_trace_%2B_portal">4. Using trace + portal</h3><p>As I mentioned, portal is the UI tool with <code>add-tap</code> so example code is basically same but we need to launch portal like below.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;comment
  &#40;calls-trace&#41;
  &#40;trace/setup-default&#41;
;; Reload this NS to test the remainder:
  &#40;do &#40;ns dev&#41;
      &#40;def portal &#40;&#40;requiring-resolve 'portal.api/open&#41;
                   {:launcher                     :vs-code
                    :portal.launcher/window-Title &#40;System/getProperty &quot;user.dir&quot;&#41;}&#41;&#41;
      &#40;add-tap &#40;requiring-resolve 'portal.api/submit&#41;&#41;&#41;
  &#40;calls-trace&#41;
  &#40;calls-trace&gt;&#41;
  &#40;calls-trace&gt;&gt;&#41;&#41;
</code></pre></p><p>I was on VS code so the new window is shown up! <img src="../img/portal.png" alt="portal-img" /></p><h2 id="what_should_i_use%3F">What should I use?</h2><p>It really depends on cases. I use all of those. This is <a href='https://github.com/jungwookim/debugging-clojure-example'>an whole example code</a>.</p>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2022-07-11-repl-driven-development.html</id>
    <link href="https://github.com/borkdude/quickblog/2022-07-11-repl-driven-development.html"/>
    <title>Clojure Live Coding</title>
    <updated>2022-07-11T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>Posted on <a href='https://www.youtube.com/watch?v=c3BOdHuqojI'>Greenlabs's youtube</a></p>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2022-05-22-has_joined_for_six_months.html</id>
    <link href="https://github.com/borkdude/quickblog/2022-05-22-has_joined_for_six_months.html"/>
    <title>Clojure 사용 6개월 후기</title>
    <updated>2022-05-22T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>지금 회사로 11월 15일에 옮겼으니 만으로 딱 6개월이 지났다. 시간이 꽤 빨리 흘렀다. 그 사이에 여러가지 많이 배운 것 같다.</p><p>우리 회사는 지금 다이나믹 타입을 가진 Lisp계열의 함수형언어인 <code>Clojure</code>를 사용 중인데 이를 6개월가량 써보면서 드는 생각들을 조금 정리해보도록 하자. 덤으로 사용하고 있는 스택들도 조금 정리해보도록 하자.</p><h1 id="%EC%9D%B8%EC%83%81">인상</h1><p>부족하거나 막힘이 없는 언어라고 느꼈다. 비즈니스 로직에 필요한 구현을 해야할 때 코드가 장황해지지 않았다. 간결했고 가독성이 높았다. 적은 코드량으로 깨끗한 코드를 짤 수 있었고 입/출력만 있고 side effects가 없는 함수들로 파이프라인만 잘 구성하면 되었다. 또한 매크로를 사용해서 함수를 만드는 함수나 새로운 함수를 쉽게 정의할 수도 있었다. 없으면 만들면 되었다. 메타프로그래밍이 쉽고 재밌었다.</p><p>처음 약 3개월동안은 타입이 없다는 불편함이 발목을 잡지 않을까 했는데 딱히 없었다. 언어의 설계가 <code>hashmap</code>을 중심으로 하고, nil에 대한 처리를 잘 하고 있어서 보통의 개발자라면 의심하지 않으면 잘 사용할 것 같다.</p><p>클래스에 얽매이지 않다보니 코드 읽기도 수월하고 이만저만 좋은게 많다.</p><h1 id="server_tech_stack">Server Tech Stack</h1><p>대충 정리하니 아래와 같다. 다른 3rd 이용 API나 사소한 것들은 제외시켰다.</p><ul><li>RESTful API: <a href='https://github.com/metosin/reitit'>Reitit</a>. Data-driven router일 뿐이다. (파이썬의 장고나 자바의 스프링 같은게 아니다)</li><li>Data-driven schemas: <a href='https://github.com/metosin/malli'>malli</a></li><li>GraphQL API: <a href='https://lacinia.readthedocs.io/en/latest/'>Lacinia</a></li><li>Dataloader: <a href='https://github.com/oliyh/superlifter'>superlifter</a></li><li>Date and Time: <a href='https://github.com/dm3/clojure.java-time'>java-time</a></li><li>HTTP<ul><li><a href='https://github.com/ring-clojure/ring'>ring</a>: HTTP server abstraction</li><li><a href='https://github.com/dakrone/clj-http'>clj-http</a>: Apache HttpComponents client wrapper</li></ul></li><li>Database: <a href='https://github.com/seancorfield/next-jdbc'>next.jdbc</a></li><li>Connection pools: <a href='https://github.com/tomekw/hikari-cp'>hikari-cp</a></li><li>Structural Migrations: <a href='https://github.com/yogthos/migratus'>Migratus</a></li><li>DSL for SQL generation: <a href='https://github.com/jkk/honeysql'>honeysql</a></li><li>Security: <a href='https://github.com/funcool/buddy'>Buddy</a></li><li>Pattern Matching: <a href='https://github.com/clojure/core.match'>core.match</a></li><li>Testing: <a href='https://github.com/lambdaisland/kaocha'>kaocha</a></li><li>Code Analysis and Linter: <a href='https://github.com/borkdude/clj-kondo'>clj-kondo</a></li><li>Error utility: <a href='https://github.com/adambard/failjure'>failjure</a></li><li>Dependency injection(<em>Managed lifecycle of stateful objects</em>): <a href='https://github.com/weavejester/integrant'>integrant</a></li></ul><h1 id="%EB%8D%94_%EC%95%8C%EC%95%84%EB%82%98%EA%B0%80%EC%95%BC%ED%95%A0_%EA%B2%83%EB%93%A4">더 알아나가야할 것들</h1><p>더 알아나가야할 것들을 안다는 것 자체가 이미 잘 알고 있다는 건데... 실제 코드에서는 core.async를 잘 사용하지 않게 되는데 지금과 같은 규모와 서비스 특성상 비동기적 처리를 할 일이 자주 있을까 싶다. 그리고 protocol 관련해서도 코드 작성을 꺼려하게 되는데 (의견이 분분) 이것도 조금 더 살펴보도록 해야겠다.</p><h1 id="%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C%EC%84%9C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%ED%95%9C%EB%8B%A4%EB%8A%94_%EA%B2%83%28dsl%EA%B4%80%EB%A0%A8%29">데이터로서 프로그래밍 한다는 것(DSL관련)</h1><p>Terraform을 비롯하여 데이터로서 행동을 정의하고 규약한다는 것은 이미 프로그래밍 세계에서 많이 이루어졌다. Graphql Schema도 이 중 하나일테고. 회사 내부에서 지금 GraphQL을 적극 사용 중인데 DSL로 만들어서 사용할 수 있을 각을 보고 있다. 조금 더 디벨롭할 수 있는 시간을 쓰도록 해야겠다.</p>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2022-02-22-clojure_urania.html</id>
    <link href="https://github.com/borkdude/quickblog/2022-02-22-clojure_urania.html"/>
    <title>Urania Notes</title>
    <updated>2022-02-22T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<h1 id="%EC%86%8C%EA%B0%9C">소개</h1><p>종종 비즈니스 로직이 DB, Cache, web services 등 여러 소스로부터 받아보고 싶은 원격 데이터에 의존한다. 이를 다루는게 보통 쉬운 일이 아니다. Urania는 비즈니스 로직을 쉽게 관리하게 해주는데 아래 3가지를 효율적으로 다룬다.</p><ul><li>batch multiple requests to the same data source</li><li>request data from multiple data sources concurrently</li><li>cache previous requests</li></ul><h1 id="%EC%9C%A0%EC%A0%80_%EA%B0%80%EC%9D%B4%EB%93%9C">유저 가이드</h1><h2 id="%EC%9B%90%EB%A6%AC">원리</h2><p>모든 프로그램은 성능과 표현력에 대해서 항상 고민이다. 쉽게 표현하면 성능이 떨어지는 경우가 있기 때문. 아래의 예시를 보자.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;require '&#91;clojure.set :refer &#91;intersection&#93;&#93;&#41;

&#40;defn friends-of
  &#91;id&#93;
  ;; ...
  &#41;

&#40;defn count-common
  &#91;a b&#93;
  &#40;count &#40;intersection a b&#41;&#41;&#41;

&#40;defn count-common-friends
  &#91;x y&#93;
  &#40;count-common &#40;friends-of x&#41; &#40;friends-of y&#41;&#41;&#41;

&#40;count-common-friends 1 2&#41;
</code></pre><p><code>&#40;friends-of x&#41;</code>와 <code>&#40;friends-of y&#41;</code>는 서로 독립적이다. 동시에 가져오면 좋겠다. 게다가, x, y가 심지어 같은 사람이면 두번할 필요도 없을 것이다. 최적화 하면 어떻게 될까? caching과 batching을 혼합적으로 생각해야한다.</p><p><code>Urania</code>는 코드를 약간 바꾸고도 <strong>데이터</strong>를 동시에 가지고 올 수 있게 해준다. 대략 아래처럼.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;require '&#91;urania.core :as u&#93;&#41;

&#40;defn count-common-friends &#91;x y&#93;
  &#40;u/map count-common
         &#40;friends-of x&#41;
         &#40;friends-of y&#41;&#41;&#41;

&#40;u/run! &#40;count-common-friends 1 2&#41;&#41;
</code></pre></p><p>보면 알겠지만 데이터 가져오는 것과 실행을 분리했다. run할 때 <code>urania</code>는 아래와 같은 일을 한다.</p><ul><li>request data from multiple data sources concurrently</li><li>batch multiple requests to the same data source</li><li>cache repeated requests</li></ul><h2 id="%EC%9B%90%EA%B2%A9%EC%97%90%EC%84%9C_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0">원격에서 데이터 가져오기</h2><p>보통 원격에서 데이터 가져오는 건 비동기적이고(asynchronous) 혹은 이거나 에러가 날 수도 있다. 그래서 <code>urania</code>가 <a href='ttps://github.com/funcool/promesa'>Promesa</a>를 사용한다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;require '&#91;promesa.core :as prom&#93;&#41;

&#40;defn remote-req &#91;id result&#93;
  &#40;prom/promise
    &#40;fn &#91;resolve reject&#93;
      &#40;let &#91;wait &#40;rand 1000&#41;&#93;
        &#40;println &#40;str &quot;--&gt;&#91; &quot; id &quot; &#93; waiting &quot; wait&#41;&#41;
        &#40;Thread/sleep wait&#41;
        &#40;println &#40;str &quot;&lt;--&#91; &quot; id &quot; &#93; finished, result: &quot; result&#41;&#41;
        &#40;resolve result&#41;&#41;&#41;&#41;&#41;
</code></pre><h2 id="remote_data_sources">Remote data sources</h2><p><code>Urania</code>의 <code>DataSource</code> protocol을 구현한 타입인 data sources를 정의해보자.</p><ul><li><strong><code>-identity</code></strong>, which returns an identifier for the resource (used for caching and deduplication).</li><li><strong><code>-fetch</code></strong>, which fetches the result from the remote data source returning a promise.</li></ul><p>대략 예시<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;require '&#91;urania.core :as u&#93;&#41;

&#40;defrecord FriendsOf &#91;id&#93;
  u/DataSource
  &#40;-identity &#91;&#95;&#93; id&#41;
  &#40;-fetch &#91;&#95; &#95;&#93;
    &#40;remote-req id &#40;set &#40;range id&#41;&#41;&#41;&#41;&#41;

&#40;defn friends-of &#91;id&#93;
  &#40;FriendsOf. id&#41;&#41;
</code></pre></p><ul><li><code>&#40;u/run! &#40;friends-of 10&#41;&#41;</code> : return promise</li><li><code>&#40;deref &#40;u/run! &#40;friends-of 10&#41;&#41;&#41;</code>: deref를 이용한 block</li><li><code>&#40;u/run!! &#40;friends-of 10&#41;&#41;</code>: block하는 두번째 방법. clojure에서는 이게 더 나음</li></ul><h3 id="%EA%B0%80%EC%A0%B8%EC%98%A8_%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0">가져온 데이터 변환하기</h3><p><code>u/map</code>을 이용해서 결과를 변환할 수 있다<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;u/run!!
  &#40;u/map dec &#40;u/map count &#40;friends-of 10&#41;&#41;&#41;&#41;
</code></pre></p><h3 id="%EA%B2%B0%EA%B3%BC%EB%93%A4%EC%9D%98_%EC%9D%98%EC%A1%B4%EC%84%B1">결과들의 의존성</h3><p>fetch 먼저하고 계산하는 로직이 있다고 하자. <code>u/mapcat</code>을 사용하면 된다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defrecord ActivityScore &#91;id&#93;
  u/DataSource
  &#40;-identity &#91;&#95;&#93; id&#41;
  &#40;-fetch &#91;&#95; &#95;&#93;
    &#40;remote-req id &#40;inc id&#41;&#41;&#41;&#41;

&#40;defn activity
  &#91;id&#93;
  &#40;ActivityScore. id&#41;&#41;
</code></pre><p>첫번째 친구의 활동성만 찾아보자.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn first-friends-activity
  &#91;id&#93;
  &#40;u/mapcat &#40;fn &#91;friends&#93;
              &#40;activity &#40;first friends&#41;&#41;&#41;
            &#40;friends-of id&#41;&#41;&#41;

&#40;u/run!! &#40;first-friends-activity 10&#41;&#41;
;; --&gt;&#91; 10 &#93; waiting 575.5289747556875
;; &lt;--&#91; 10 &#93; finished, result: #{0 7 1 4 6 3 2 9 5 8}
;; --&gt;&#91; 0 &#93; waiting 63.24540090623976
;; &lt;--&#91; 0 &#93; finished, result: 1
;; =&gt; 1
</code></pre></p><p>모든 친구에 대해서 한다면?<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn friends-activity
  &#91;id&#93;
  &#40;u/mapcat &#40;fn &#91;friends&#93;
              &#40;u/collect &#40;map activity friends&#41;&#41;&#41;
            &#40;friends-of id&#41;&#41;&#41;

&#40;u/run!! &#40;friends-activity 5&#41;&#41;
;; --&gt;&#91; 5 &#93; waiting 480.8846764476696
;; &lt;--&#91; 5 &#93; finished, result: #{0 1 4 3 2}
;; --&gt;&#91; 0 &#93; waiting 488.58045819535687
;; --&gt;&#91; 1 &#93; waiting 87.96784013662884
;; --&gt;&#91; 4 &#93; waiting 868.2747930486679
;; &lt;--&#91; 1 &#93; finished, result: 2
;; --&gt;&#91; 3 &#93; waiting 293.59429652774116
;; &lt;--&#91; 3 &#93; finished, result: 4
;; --&gt;&#91; 2 &#93; waiting 280.68098217346835
;; &lt;--&#91; 0 &#93; finished, result: 1
;; &lt;--&#91; 2 &#93; finished, result: 3
;; &lt;--&#91; 4 &#93; finished, result: 5
;; =&gt; &#91;1 2 5 4 3&#93;
</code></pre></p><p>동시에 실행되는 것을 위에서 확인할 수 있다. 게다가 알아서 중복 요청은 하지 않는다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;u/run!! &#40;u/collect &#91;&#40;friends-of 1&#41; &#40;friends-of 2&#41; &#40;friends-of 2&#41;&#93;&#41;&#41;
;; --&gt;&#91; 2 &#93; waiting 634.8383950264134
;; --&gt;&#91; 1 &#93; waiting 924.8381446535985
;; &lt;--&#91; 2 &#93; finished, result: #{0 1}
;; &lt;--&#91; 1 &#93; finished, result: #{0}
;; =&gt; &#91;#{0} #{0 1} #{0 1}&#93;
</code></pre></p><p><code>collect</code> + <code>mapcat</code>은 <code>traverse</code>로 대체될 수 있긴 하다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn friends-activity
  &#91;id&#93;
  &#40;u/traverse activity &#40;friends-of id&#41;&#41;&#41;
</code></pre></p><h3 id="%EB%B0%B0%EC%B9%98_%EC%9A%94%EC%B2%AD">배치 요청</h3><p>위의 예시들에서 <code>urania</code>가 중복요청들을 잘 없앴는데 여전히 개선 여지가 있다. 위 예시 <code>u/collect</code>에서 동일한 데이터 소스에 대한 요청이 동시에(concurrently) 실행되는 방법을 봤다. 이걸 batch로 만들어보자.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;extend-type ActivityScore
  u/BatchedSource
  &#40;-fetch-multi &#91;score scores &#95;&#93;
    &#40;let &#91;ids &#40;cons &#40;:id score&#41; &#40;map :id scores&#41;&#41;&#93;
      &#40;remote-req ids &#40;zipmap ids &#40;map inc ids&#41;&#41;&#41;&#41;&#41;&#41;
</code></pre><p>여기 보면 한번에 요청했다. n+1(6)번의 요청이 2번으로 줄었다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;u/run!! &#40;friends-activity 5&#41;&#41;
;; --&gt;&#91; 5 &#93; waiting 123.11807342157954
;; &lt;--&#91; 5 &#93; finished, result: #{0 1 4 3 2}
;; --&gt;&#91; &#40;0 1 4 3 2&#41; &#93; waiting 97.95578032830765
;; &lt;--&#91; &#40;0 1 4 3 2&#41; &#93; finished, result: {0 1, 1 2, 4 5, 3 4, 2 3}
;; &#91;1 2 5 4 3&#93;
</code></pre></p><h1 id="%EC%9D%91%EC%9A%A9">응용</h1><p>Cache, Executor, Environment 관련된 건데 공식 문서보고 확인하자.</p><h1 id="reference">Reference</h1><ul><li><a href='ttp://funcool.github.io/urania/latest/'>Document</a></li><li><a href='ttps://github.com/funcool/urania'>Github</a></li><li><a href='ttps://github.com/funcool/promesa'>Promesa</a></li></ul>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2022-01-12-clojure_malli_introduction.html</id>
    <link href="https://github.com/borkdude/quickblog/2022-01-12-clojure_malli_introduction.html"/>
    <title>Clojure Malli</title>
    <updated>2022-01-12T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<h1 id="%EB%8F%99%EA%B8%B0">동기</h1><p>처음에는 type system을 일부 빌려오고 싶었다. 클로저가 동적 타입의 언어이다 보니 개발하는 사람은 데이터 스키마를 어느정도 머릿 속에 가지고 있고 디버깅도 하다보니 오히려 속도를 낼 수 있는 장점이 있지만 해당 코드를 개발하지 않은 사람이 봤을 때에는 추가 개발이 힘든 점이 있다고 느꼈다.</p><p>그래서 리서치를 하다가 Data-driven development를 알게 되었고 찾다보니 Malli를 썼을 때 장점이 있어 보였다.</p><h1 id="%EC%86%8C%EA%B0%9C">소개</h1><p>Malli는 Data-driven 개발을 위해 만들어진 clojure library이다. 새로운 validation과 specification을 제시한다. schema definition, validation, error, value and schema transformation, generation and registries 같은 것들을 포함하고 있다.</p><p>간단하게 어떻게 동작하는지 한번 살펴보자.</p><h1 id="syntax%EC%99%80_simple_validation">Syntax와 simple validation</h1><p>Vector 방식으로 정의<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;require '&#91;malli.core :as m&#93;&#41;

&#40;def non-empty-string
  &#40;m/schema &#91;:string {:min 1}&#93;&#41;&#41;

&#40;m/schema? non-empty-string&#41;
; =&gt; true

&#40;m/validate non-empty-string &quot;&quot;&#41;
; =&gt; false

&#40;m/validate non-empty-string &quot;kikka&quot;&#41;
; =&gt; true

&#40;m/form non-empty-string&#41;
; =&gt; &#91;:string {:min 1}&#93;
</code></pre></p><p>Map 방식으로 정의<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;def non-empty-string
  &#40;m/from-ast {:type :string
               :properties {:min 1}}&#41;&#41;

&#40;m/schema? non-empty-string&#41;
; =&gt; true

&#40;m/validate non-empty-string &quot;&quot;&#41;
; =&gt; false

&#40;m/validate non-empty-string &quot;kikka&quot;&#41;
; =&gt; true

&#40;m/ast non-empty-string&#41;
; =&gt; {:type :string,
;     :properties {:min 1}}
</code></pre></p><p>Schema AST를 쓰는 방식이 훨씬 빠르다고 한다.</p><h1 id="%EA%B0%84%EB%8B%A8%ED%95%9C_schema_definition">간단한 schema definition</h1><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;m/validate &#91;:sequential any?&#93; &#40;list &quot;this&quot; 'is :number 42&#41;&#41;
;; =&gt; true

&#40;m/validate &#91;:vector int?&#93; &#91;1 2 3&#93;&#41;
;; =&gt; true

&#40;m/validate &#91;:vector int?&#93; &#40;list 1 2 3&#41;&#41;
;; =&gt; false

; fixed length vector
&#40;m/validate &#91;:tuple keyword? string? number?&#93; &#91;:bing &quot;bang&quot; 42&#93;&#41;
;; =&gt; true


&#40;m/validate &#91;:repeat {:min 2, :max 4} int?&#93; &#91;1&#93;&#41; ; =&gt; false
&#40;m/validate &#91;:repeat {:min 2, :max 4} int?&#93; &#91;1 2&#93;&#41; ; =&gt; true
&#40;m/validate &#91;:repeat {:min 2, :max 4} int?&#93; &#91;1 2 3 4&#93;&#41; ; =&gt; true ; :max is inclusive
&#40;m/validate &#91;:repeat {:min 2, :max 4} int?&#93; &#91;1 2 3 4 5&#93;&#41; ; =&gt; false


; string schemas
&#40;m/validate string? &quot;kikka&quot;&#41; ; using a predicate

&#40;m/validate :string &quot;kikka&quot;&#41; ; using :string schema
;; =&gt; true

&#40;m/validate &#91;:string {:min 1, :max 4}&#93; &quot;&quot;&#41;
;; =&gt; false

; maybe schemas
&#40;m/validate &#91;:maybe string?&#93; &quot;bingo&quot;&#41;
;; =&gt; true

&#40;m/validate &#91;:maybe string?&#93; nil&#41;
;; =&gt; true

&#40;m/validate &#91;:maybe string?&#93; :bingo&#41;
;; =&gt; false

; fn schemas
&#40;def my-schema
  &#91;:and
   &#91;:map
    &#91;:x int?&#93;
    &#91;:y int?&#93;&#93;
   &#91;:fn &#40;fn &#91;{:keys &#91;x y&#93;}&#93; &#40;&gt; x y&#41;&#41;&#93;&#93;&#41;
   
&#40;m/validate my-schema {:x 1, :y 0}&#41;
; =&gt; true

&#40;m/validate my-schema {:x 1, :y 2}&#41;
; =&gt; false

&#40;def pants-schema
  &#91;:and
   &#91;:map
    &#91;:id int?&#93;
    &#91;:size {:optional true} &#91;:maybe :int&#93;&#93;
    &#91;:size-alphabet {:optional true} &#91;:maybe &#91;:enum &quot;S&quot; &quot;M&quot; &quot;L&quot;&#93;&#93;&#93;&#93;
   &#91;:fn {:error/message &quot;size and size alphabet should be nil-matched&quot;}
    '&#40;fn &#91;{:keys &#91;size size-alphabet&#93;}&#93;
       &#40;or &#40;and &#40;nil? size&#41; &#40;nil? size-alphabet&#41;&#41;
           &#40;and &#40;some? size&#41; &#40;some? size-alphabet&#41;&#41;&#41;&#41;&#93;&#93;&#41;

&#40;m/validate pants-schema {:id   1
                          :size nil
                          :size-alphabet &quot;S&quot;}&#41;
; =&gt; false
</code></pre><h1 id="%ED%95%A8%EC%88%98%EC%97%90%EC%84%9C_%EC%96%B4%EB%96%BB%EA%B2%8C_%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0_%EC%9E%88%EB%8A%94%EC%A7%80">함수에서 어떻게 사용하고 있는지</h1><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn foo-meta
  &quot;schema via var metadataz&quot;
  {:malli/schema &#91;:=&gt; &#91;:cat :int&#93; :int&#93;}
  &#91;x&#93;
  &#40;inc x&#41;&#41;

&#40;m/=&gt; foo-declare &#91;:=&gt; &#91;:cat :int&#93; :int&#93;&#41;
&#40;defn foo-declare
  &quot;schema via separate declaration&quot;
  &#91;x&#93;
  &#40;inc x&#41;&#41;

&#40;foo-meta 1&#41; ; ok
&#40;foo-meta &quot;1&quot;&#41; ; clj-kondo가 빨간 줄 그어줌

&#40;foo-declare 1&#41; ; ok
&#40;foo-declare 1&#41; ; 역시 clj-kondo가 빨간 줄 그어줌
</code></pre><h1 id="errors">Errors</h1><pre class="language-clojure"><code class="lang-clojure language-clojure">; 바로 알아보기 힘들다
&#40;m/validate pants-schema {:id   1
                          :size nil
                          :size-alphabet &quot;S&quot;}&#41;

&#40;-&gt; pants-schema
    &#40;m/explain {:id 1}&#41;
    &#40;me/humanize&#41;&#41;
</code></pre><h1 id="value_transformation">Value transformation</h1><p>Default Transformers: <code>string-transformer</code>, <code>json-transformer</code>, <code>strip-extra-keys-transformer</code>, <code>default-value-transformer</code> and <code>key-transformer</code>.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;m/decode int? &quot;42&quot; mt/string-transformer&#41;
; 42

&#40;m/encode int? 42 mt/string-transformer&#41;
; &quot;42&quot;

&#40;m/decode
  Address
  {:id &quot;Lillan&quot;,
   :tags &#91;&quot;coffee&quot; &quot;artesan&quot; &quot;garden&quot;&#93;,
   :address {:street &quot;Ahlmanintie 29&quot;
             :city &quot;Tampere&quot;
             :zip 33100
             :lonlat &#91;61.4858322 23.7854658&#93;}}
  mt/json-transformer&#41;
;{:id &quot;Lillan&quot;,
; :tags #{:coffee :artesan :garden},
; :address {:street &quot;Ahlmanintie 29&quot;
;           :city &quot;Tampere&quot;
;           :zip 33100
;           :lonlat &#91;61.4858322 23.7854658&#93;}}

&#40;m/encode
  Address
  {:id &quot;Lillan&quot;,
   :tags &#91;&quot;coffee&quot; &quot;artesan&quot; &quot;garden&quot;&#93;,
   :address {:street &quot;Ahlmanintie 29&quot;
             :city &quot;Tampere&quot;
             :zip 33100
             :lonlat &#91;61.4858322 23.7854658&#93;}}
  &#40;mt/key-transformer {:encode name}&#41;&#41;
;{&quot;id&quot; &quot;Lillan&quot;,
; &quot;tags&quot; &#91;&quot;coffee&quot; &quot;artesan&quot; &quot;garden&quot;&#93;,
; &quot;address&quot; {&quot;street&quot; &quot;Ahlmanintie 29&quot;
;            &quot;city&quot; &quot;Tampere&quot;
;            &quot;zip&quot; 33100
;            &quot;lonlat&quot; &#91;61.4858322 23.7854658&#93;}}

&#40;def strict-json-transformer
  &#40;mt/transformer
    mt/strip-extra-keys-transformer
    mt/json-transformer&#41;&#41;

&#40;m/decode
  Address
  {:id &quot;Lillan&quot;,
   :EVIL &quot;LYN&quot;
   :tags &#91;&quot;coffee&quot; &quot;artesan&quot; &quot;garden&quot;&#93;,
   :address {:street &quot;Ahlmanintie 29&quot;
             :DARK &quot;ORKO&quot;
             :city &quot;Tampere&quot;
             :zip 33100
             :lonlat &#91;61.4858322 23.7854658&#93;}}
  strict-json-transformer&#41;
;{:id &quot;Lillan&quot;,
; :tags #{:coffee :artesan :garden},
; :address {:street &quot;Ahlmanintie 29&quot;
;           :city &quot;Tampere&quot;
;           :zip 33100
;           :lonlat &#91;61.4858322 23.7854658&#93;}}

; 종합 예제
&#40;m/encode
  &#91;:map {:default {}}
   &#91;:a &#91;int? {:default 1}&#93;&#93;
   &#91;:b &#91;:vector {:default &#91;1 2 3&#93;} int?&#93;&#93;
   &#91;:c &#91;:map {:default {}}
        &#91;:x &#91;int? {:default 42}&#93;&#93;
        &#91;:y int?&#93;&#93;&#93;
   &#91;:d &#91;:map
        &#91;:x &#91;int? {:default 42}&#93;&#93;
        &#91;:y int?&#93;&#93;&#93;
   &#91;:e int?&#93;&#93;
  nil
  &#40;mt/transformer
    mt/default-value-transformer
    mt/string-transformer&#41;&#41;
;{:a &quot;1&quot;
; :b &#91;&quot;1&quot; &quot;2&quot; &quot;3&quot;&#93;
; :c {:x &quot;42&quot;}}
</code></pre><h1 id="schema_generation">Schema generation</h1><p>Schema 추론<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;require '&#91;malli.provider :as mp&#93;&#41;

&#40;def samples
  &#91;{:id &quot;Lillan&quot;
    :tags #{:artesan :coffee :hotel}
    :address {:street &quot;Ahlmanintie 29&quot;
              :city &quot;Tampere&quot;
              :zip 33100
              :lonlat &#91;61.4858322, 23.7854658&#93;}}
   {:id &quot;Huber&quot;,
    :description &quot;Beefy place&quot;
    :tags #{:beef :wine :beer}
    :address {:street &quot;Aleksis Kiven katu 13&quot;
              :city &quot;Tampere&quot;
              :zip 33200
              :lonlat &#91;61.4963599 23.7604916&#93;}}&#93;&#41;

&#40;mp/provide samples&#41;
;&#91;:map
; &#91;:id string?&#93;
; &#91;:tags &#91;:set keyword?&#93;&#93;
; &#91;:address
;  &#91;:map
;   &#91;:street string?&#93;
;   &#91;:city string?&#93;
;   &#91;:zip number?&#93;
;   &#91;:lonlat &#91;:vector double?&#93;&#93;&#93;&#93;
; &#91;:description {:optional true} string?&#93;&#93;
</code></pre></p><h1 id="value_generation">Value generation</h1><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;mg/generate pants-schema {:seed 2}&#41;
; =&gt; {:id -28, :size 8083038, :size-alphabet &quot;M&quot;}
</code></pre><h1 id="performance">Performance</h1><p>ideomatic clojure보다 훨씬 빠르다고 한다. 직접 테스트는 안하고 결과만 공유한다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;require '&#91;criterium.core :as cc&#93;&#41;

&#40;def valid {:x true, :y 1, :z &quot;zorro&quot;}&#41;

;; idomatic clojure 54ns
&#40;let &#91;valid? &#40;fn &#91;{:keys &#91;x y z&#93;}&#93;
               &#40;and &#40;boolean? x&#41;
                    &#40;if y &#40;int? y&#41; true&#41;
                    &#40;string? z&#41;&#41;&#41;&#93;
  &#40;assert &#40;valid? valid&#41;&#41;
  &#40;cc/quick-bench &#40;valid? valid&#41;&#41;&#41;

&#40;require '&#91;malli.core :as m&#93;&#41;

;; malli 39ns
&#40;let &#91;valid? &#40;m/validator
               &#91;:map
                &#91;:x :boolean&#93;
                &#91;:y {:optional true} :int&#93;
                &#91;:z :string&#93;&#93;&#41;&#93;
  &#40;assert &#40;valid? valid&#41;&#41;
  &#40;cc/quick-bench &#40;valid? valid&#41;&#41;&#41;
</code></pre></p><h1 id="%EC%9A%B0%EB%A6%AC_%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98_%ED%99%9C%EC%9A%A9_-_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%9E%85%EB%A0%A5%2F%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EC%8B%9C_%EA%B0%92_validation%EC%9D%84_%ED%95%B4%EB%B3%B4%EC%9E%90">우리 프로젝트에서의 활용 - 데이터베이스 입력/업데이트시 값 validation을 해보자</h1><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;def subsidy-schema
  &#91;:and
   &#91;:map
    &#91;:id int?&#93;
    &#91;:area int?&#93;
    &#91;:area-ineqaulity &#91;:enum &quot;&gt;=&quot; &quot;&gt;&quot; &quot;&lt;&quot; &quot;&lt;=&quot;&#93;&#93;&#93;
   &#91;:fn {:error/message &quot;area and area-inequality는 nil match가 되어야함&quot;}
    &#40;fn &#91;{:keys &#91;area area-ineqaulity&#93;}&#93;
      &#40;or &#40;and &#40;nil? area&#41; &#40;nil? area-ineqaulity&#41;&#41;
          &#40;and &#40;some? area&#41; &#40;some? area-ineqaulity&#41;&#41;&#41;&#41;&#93;&#93;&#41;

&#40;defn insert-subsidy-info
  {:malli/schema &#91;:=&gt; &#91;:cat subsidy-schema&#93; :nil&#93;}
  &#91;subsidy&#93;
  &#40;prn subsidy&#41;&#41;
</code></pre><h1 id="spec%2C_schema_and_malli">Spec, Schema and Malli</h1><p><code>Schema</code>라는게 있는데 다 좋은데, serializing이랑 de-serializing할 때 non-trivial하다. <code>Spec</code>도 개쩌는데, <code>runtime transformation</code>을 지원하지 않는게 가장 큰 흠이다. <code>malli</code>라는 건 다이나믹 시스템 개발에서 모든 것을 다 지원하기 위해 등장했다. Spec은 runtime transformation이 없다. 그리고 Spec은 global registry 하나를 통해서 다 spec을 관리하는데 Malli는 그럴 필요는 없다. schema와 registry를 값처럼 프로그래밍을 할 수 있다. null이나 optional한 것들도 더 쉽게 처리할 수 있다. 또한 Spec은 schema를 표현하기 위해 macro를 사용한다. 하지만 malli는 vector와 map을 사용한 pure data 그 자체이다. Data가 곧 system이라고 했을 때 더 쉽게 받아들일 수 있다. Spec, Schema 그리고 Malli는 하나만 써야하는 것은 아니고 같이 사용될 수 있다는 것이 중요하다.</p><h1 id="reference">Reference</h1><ul><li><a href='https://github.com/metosin/malli'>malli github</a></li><li><a href='https://www.metosin.fi/blog/malli/'>malli blog 1</a></li><li><a href='https://www.karimarttila.fi/clojure/2020/12/07/malli-clojure-library.html'>malli blog 2</a></li></ul>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2021-12-18-understanding-clojure-macro.html</id>
    <link href="https://github.com/borkdude/quickblog/2021-12-18-understanding-clojure-macro.html"/>
    <title>Clojure macro 초급 딱지 떼기</title>
    <updated>2021-12-18T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<h1 id="%EB%AA%A9%ED%91%9C">목표</h1><p>클로저 매크로를 할 일은 별로 없을 것 같고 보고 읽을 줄 아는 정도의 지식을 쌓자</p><h1 id="%EC%95%8C%EA%B1%B0%EB%9D%BC_%EC%83%9D%EA%B0%81%ED%95%98%EA%B1%B0%EB%82%98_%EC%95%8C%EB%A9%B4_%EC%A2%8B%EC%9D%80_%EB%82%B4%EC%9A%A9">알거라 생각하거나 알면 좋은 내용</h1><ul><li>clojure는 lisp 계열의 언어이다.</li><li>클로저의 기본 문법을 알고 있다.</li></ul><h1 id="%EC%82%AC%EC%A0%84_%EC%A7%80%EC%8B%9D">사전 지식</h1><p>사전 지식이라기 보다는 이 글 내내 반복해서 나오는 것들에 대해서 미리 요약해둔 것이라고 보면 된다. 이 글을 다 읽고도 아래 나열된 것들을 이해 못했다면 글쓴이의 잘못이다.</p><ul><li><code>symbol</code>: <code>심볼</code>, <code>기호</code>라고 부른다. 값을 가지지 않는 심볼이다. 평가된 심볼인지 평가되지 않는 심볼인지 구분할 수 있다.</li><li><code>'</code>: <code>single quoting</code>이라고 부른다. <strong>평가(evaluation)을 꺼놓는 것(turn off). 평가되지 않은 데이터 구조를 반환한다. 심볼을 그대로 반환하기 위함이다.</strong></li><li>`` <code> ``: </code>syntax quoting<code>이라고 부른다. single quote와 비슷하지만 중요한 2가지 다른 점이 있다. 하나는 namespace를 포함한 심볼을 반환한다.&#40;the fully qualified symbols&#41; 두번째는 </code>~<code>를 사용해서 </code>unquote<code>하게 만들 수 있게 한다. 즉, 평가되지 않게 한 것을 평가를 시켜버린다. 다르게 말하면 </code>syntax quoting` 능력을 없애버린다.</li><li><code>&#126;</code>: <code>syntax quoting</code>에서 설명했지만 <code>quoting</code>된 것을 <code>unquote</code>해버린다. 반복하자면 평가되지 않게 한 것을 평가를 시켜버린다.</li><li><code>&#126;@</code>: <code>unquote slicing</code>이라고 부른다. 망치 모양이랑 비슷하다. <code>seqable data structure</code>를 unwrap한다고 보면 된다. 간단하게 생각해서 괄호를 벗겨내고 그 발가벗은 순서대로 둔다고 생각하자.</li><li><code>&#126;'</code>: 일종의 꼼수인데, <code>syntax quote</code>으로 평가를 미뤘는데 let binding 같은 것 할 때 네임스페이스가 붙어 있는데, 네임스페이스를 없애줘야할 때 <code>'</code>를 통해 평가 되지 않게 다시 하고 <code>&#126;</code>를 통해 다시 평가하여 심볼을 얻을 때 필요하다. 즉, 매크로 안에서 심볼을 만들어써야될 때 필요한데 아니면 <code>symbol#</code>을 직접 사용해도 된다. 사실 <code>symbol#</code>은 사실 auto-gensym'd 심볼이다.</li><li><code>symbol#</code>: auto-gensym'd symbol인데 <code>&#126;'</code>는 지양하고 얘를 쓰도록 하자.</li><li><code>gensym</code>: variable capture에 쓰인다. 고유한 symbol을 만들어준다.</li></ul><h1 id="%EC%98%88%EC%A0%9C%EB%A5%BC_%EC%82%AC%EC%A0%84_%EC%A7%80%EC%8B%9D%EC%9D%84_%EA%B0%80%EB%8B%A4%EB%93%AC%EC%9E%90">예제를 사전 지식을 가다듬자</h1><p>예제는 <a href='ttps://www.braveclojure.com/writing-macros/'>Brave Clojure</a>를 일부 참고했다.</p><p>평가된 <code>+</code> 심볼.<pre class="language-clojure"><code class="lang-clojure language-clojure">+
; =&gt; #function&#91;clojure.core/+&#93;
</code></pre></p><p>평가되지 않은 <code>+</code> 심볼.<pre class="language-clojure"><code class="lang-clojure language-clojure">'+
; +
&#40;quote +&#41;
; +
</code></pre></p><p>보통 클로저에서 사용하는 (함수 인자 인자) 표현식이다. 괄호 안의 표현이 평가되었다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;+ 1 2&#41;
; =&gt; 3
</code></pre></p><p><code>single quote</code>를 사용해보자. 괄호 안의 표현이 평가되지 않았다.<pre class="language-clojure"><code class="lang-clojure language-clojure">'&#40;+ 1 2&#41;
; =&gt; &#40;+ 1 2&#41;
</code></pre></p><p><code>syntax quote</code>를 사용해보자. <code>+</code> 함수의 네임스페이스를 포함한 심볼을 반환했다.<pre class="language-clojure"><code class="lang-clojure language-clojure">`&#40;+ 1 2&#41;
; =&gt; &#40;clojure.core/+ 1 2&#41;
</code></pre></p><p>조금 어색하지만 <code>syntax quote</code>를 하고도 <code>&#126;</code>를 이용해서 평가를 해보자.<pre class="language-clojure"><code class="lang-clojure language-clojure">`&#126;&#40;+ 1 2&#41;
; =&gt; 3
</code></pre></p><p>생각해보자. 우리가 평소에 사용하는 방식이다. 쉽다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;+ 1 &#40;inc 1&#41;&#41;
; =&gt; 3
</code></pre></p><p>이거는 어떻게 될까? 위에서 생각한대로 평가를 미룬다고 생각해보자. 괄호 안의 평가들이 다 미루어졌다.<pre class="language-clojure"><code class="lang-clojure language-clojure">`&#40;+ 1 &#40;inc 1&#41;&#41;
; =&gt; &#40;clojure.core/+ 1 &#40;clojure.core/inc 1&#41;&#41;
</code></pre></p><p><code>&#40;inc 1&#41;</code>는 평가가 되었으면 한다. 그럼 이렇게 해보면 된다.<pre class="language-clojure"><code class="lang-clojure language-clojure">`&#40;+ 1 &#126;&#40;inc 1&#41;&#41;
; =&gt; &#40;clojure.core/+ 1 2&#41;
</code></pre></p><p>이렇게 하면 어떻게 될까?<pre class="language-clojure"><code class="lang-clojure language-clojure">`&#40;+ 1 &#40;&#126;inc 1&#41;&#41;
; =&gt; &#40;clojure.core/+ 1 &#40;#function&#91;clojure.core/inc&#93; 1&#41;&#41;
; inc만 평가되어 나왔다.
</code></pre></p><p><code>unquote slicing</code>을 알아보자. 먼저 우리가 알던 것을 보자. 평가를 꺼뒀지만 두번째 괄호 안에서는 평가를 바로 하도록 <code>&#126;</code>를 썼다. list가 잘 반환되었다.<pre class="language-clojure"><code class="lang-clojure language-clojure">`&#40;+ &#126;&#40;list 1 2 3&#41;&#41;
; =&gt; &#40;clojure.core/+ &#40;1 2 3&#41;&#41;
</code></pre></p><p>망치로 바꿔보자. 이렇게 하면 unwrap된 상태이다.<pre class="language-clojure"><code class="lang-clojure language-clojure">`&#40;+ &#126;@&#40;list 1 2 3&#41;&#41;
; =&gt; &#40;clojure.core/+ 1 2 3&#41;
</code></pre></p><p>gensym은 아래처럼 만든다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;gensym foo&#41;
; =&gt; foo7366
</code></pre></p><p>auto-gensym'd는 아래처럼 만든다. unquote 상태에서 #을 붙인다..<pre class="language-clojure"><code class="lang-clojure language-clojure">`foo#
; =&gt; foo&#95;&#95;7368&#95;&#95;auto&#95;&#95;
</code></pre></p><p>이것처럼 활용할 수 있다.<pre class="language-clojure"><code class="lang-clojure language-clojure">`&#40;let &#91;my-symbol# 3&#93;
    &#40;...&#41;&#41;
</code></pre></p><h1 id="reference">Reference</h1><ul><li><a href='ttps://green-labs.github.io/the-macro'>그린랩스 기술블로그 매크로</a></li><li><a href='ttps://eunmin.gitbooks.io/clojure-for-beginners/content/9_macros.html'>eunmin-gitbooks-macro</a></li><li><a href='ttps://www.braveclojure.com/writing-macros/'>Writing macros in Brave Clojure </a></li></ul>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2021-11-26-clojure-polymorphism.html</id>
    <link href="https://github.com/borkdude/quickblog/2021-11-26-clojure-polymorphism.html"/>
    <title>Clojure Polymorphism</title>
    <updated>2021-11-26T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p>clojure의 다형성에 대해서 알아보자</p><p>다형성이라고 불러도 될 지 모르겠는데 약간 디자인 패턴 중 하나인 팩토리 패턴과 유사하다고도 볼 수 있겠다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defmulti 이름 docString? attr-map? 디스패치함수 &amp; 옵션&#41;

&#40;defmethod 멀티펑션 디스패치값 &amp; fn-tail&#41; ; fn-tail이라고 하면 파라미터와 함수 내용을 말하는 것으로 확인
</code></pre><p>예제들을 여러개 봤는데 처음엔 이해하기 힘들었는데 천천히 이해해보도록 하자.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;ns were-creatures&#41;
➊ &#40;defmulti full-moon-behavior &#40;fn &#91;were-creature&#93; &#40;:were-type were-creature&#41;&#41;&#41; ; multifn 함수 이름과 함수 내용을 정의했다
➋ &#40;defmethod full-moon-behavior :wolf
  &#91;were-creature&#93;
  &#40;str &#40;:name were-creature&#41; &quot; will howl and murder&quot;&#41;&#41; ; multifn이름을 그대로 쓰고 두번째 인자는 파라미터로 받은 후 디스패치 함수의 실행 결과값이 :wolf와 대응되는지 확인하는 인자, 그리고 그게 대응된다면 마지막에 fn-tail이 호출된다
➌ &#40;defmethod full-moon-behavior :simmons
  &#91;were-creature&#93;
  &#40;str &#40;:name were-creature&#41; &quot; will encourage people and sweat to the oldies&quot;&#41;&#41;

&#40;full-moon-behavior {:were-type :wolf
➍                      :name &quot;Rachel from next door&quot;}&#41;
; =&gt; &quot;Rachel from next door will howl and murder&quot;

&#40;full-moon-behavior {:name &quot;Andy the baker&quot;
➎                      :were-type :simmons}&#41;
; =&gt; &quot;Andy the baker will encourage people and sweat to the oldies&quot;
</code></pre><h1 id="reference">Reference</h1><ul><li><a href='https://www.braveclojure.com/multimethods-records-protocols/'>brave clojure multimethods</a></li><li><a href='https://clojuredocs.org/clojure.core/defmulti'>defmulti</a></li><li><a href='https://clojuredocs.org/clojure.core/defmethod'>defmethod</a></li></ul>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2021-11-26-clojure-bootcamp-retro.html</id>
    <link href="https://github.com/borkdude/quickblog/2021-11-26-clojure-bootcamp-retro.html"/>
    <title>Restrospectives of the clojure advenutre</title>
    <updated>2021-11-26T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<h1 id="%ED%9A%8C%EA%B3%A0">회고</h1><p>Clojure 부트캠프의 <code>회고</code>를 해보자.</p><h2 id="%EB%AC%B8%ED%99%94">문화</h2><p>회사의 문화에 감사하자. 회사에서 순수하게 공부만을 위해서 2주의 시간을 부여 받은 적이 있었을까? 나는 이전의 회사들에서도 처음 배우는 언어, 프레임워크들에 대해서 <code>학습에만 집중할 시간</code>을 받은 적은 없었다. 보통은 주요 로직을 건드리지 않는 간단한 기능을 만들면서 언어나 프레임워크 등에 익숙해지는 시간을 가지며 혼자서 낑낑되고는 했기 때문에. 뭐가 더 빠르게 배우고 늦게 배우고 좋고 나쁘고를 떠나서 일단 <code>문제 푸는 것</code>과 <code>새로운 언어를 학습하는 것</code>을 할 수 있는 시간과 지원을 받아서 기분이 좋았다. 앞으로 이런 날은 없겠지...</p><h2 id="%EB%A6%AC%EB%B7%B0%EC%96%B4">리뷰어</h2><p>리뷰어들이 리뷰를 적당히 빡빡하게 해준 것 같다. 너무 사소하다고 느낀 것들도 있었지만 코드 작성에 굉장히 도움을 많이 준 팁들도 있었고, 새로운 core 함수들 같은 것도 많이 알게 된 것 같다. 확실한 건 모든 리뷰들은 일관성이 있었는데 프로덕션 레벨에서 이 코드가 작성된다고 생각할 때, 어떤 방향으로 코드가 작성되어야하는지를 제시해줬다.</p><h2 id="%EB%B9%A0%EB%A5%B8_%EA%B0%9C%EC%84%A0">빠른 개선</h2><p>그리고 특히 1주차에 언어에 익숙치 잘 몰라서 생기는 사소한 문제들로 인해서 막히는 부분들이 있었는데 좀 쉽게 쉽게 질문할 수 있었으면 좋겠다고 생각해서 의견을 제시(매니저님이 들어주었는데)했는데 이것이 2주차부터 바로 반영되어서 시간이나 <code>심리적 안도감</code>을 많이 가졌던 것 같다. 그 전에는 혼자 있는 느낌을 받았는데 이후에는 함께 하는 느낌이었다.</p><h2 id="%ED%81%B4%EB%A1%9C%EC%A0%80_%EA%B7%B8_%EC%9E%90%EC%B2%B4">클로저 그 자체</h2><p>솔직히 딱히 단점은 잘 모르겠다. 처음에는 <code>Sequence</code>, <code>Collections</code>가 혼동되고 <code>list</code>나 <code>vector</code> 중에 뭘 써야하나 등등에 대해서 헷갈렸는데 지금도 여전히 헷갈리긴 하지만 사용에는 큰 문제는 없는 것 같다. 클로저스럽게 개발한다는게 뭔지는 모르겠지만 클로저의 기본 of 기본에 대해서는 아주 조금 이해한 것 같다. <strong><code>사실 아직 잘 모르겠지만 재밌는 건 맞다.</code></strong> 그걸로 됐다.</p><h2 id="%EA%B7%B8%EB%9F%BC%EC%97%90%EB%8F%84_%EC%95%84%EC%89%AC%EC%9A%B4_%EC%A0%90">그럼에도 아쉬운 점</h2><p>아쉬운 점이 없다면 더 아쉬우니 아쉬운 점도 기록해보자.</p><ul><li>내가 클로저를 잘 이해하고 사용 있는 건지 모를 때가 종종 있다: 말 그대로다. 지금도 잘 하고 있는 건지 모르겠다. 뚜렷한 목표 같은게 없다랄까?</li><li>AOC 부트캠프의 목적을 적절히 상기시키면 좋겠다<ul><li>클로저스럽게 코드짜기</li><li>문제 풀이도 중요하지만 프로덕션 코드처럼 재사용 가능하게 짜보는 것</li></ul></li><li>파일을 한줄씩 읽지 말고 꼭 한번에 다 읽으라고 미리 알려주면 좋겠다. <&ndash; 이거에 잘못빠지면 문제 풀이 방식이 달라져서...</li><li>다른 사람이 기존에 작성했던 코드들도 잘 아카이빙 되어있어서 적어도 푼 문제에 대해서는 다른 사람의 코드도 보면 좋겠다. 잘 짠 코드나.</li></ul><h1 id="reference">Reference</h1><ul><li><a href='ttps://github.com/jungwookim/aoc-exercise/tree/master/src'>my github repo</a></li><li><a href='ttps://adventofcode.com/2018/day/3'>advent of code</a></li></ul>]]></content>
  </entry>
  <entry>
    <id>https://github.com/borkdude/quickblog/2021-11-17-training_clojure_with_aoc.html</id>
    <link href="https://github.com/borkdude/quickblog/2021-11-17-training_clojure_with_aoc.html"/>
    <title>Clojure와 친해지기</title>
    <updated>2021-11-17T23:59:59+00:00</updated>
    <content type="html"><![CDATA[<p><code>clojure</code>와 친해져보도록 하자. <code>clojure</code>가 <code>JVM</code> 위에서 동작한다는 성질이나 함수형 언어로서의 특성을 글로 배우기 보다는 기본기를 <a href='ttps://adventofcode.com/2018/day/3'><code>advent of code</code></a>에서 닦아보도록 하자. 전체 코드는 <a href='ttps://github.com/jungwookim/aoc-exercise/tree/master/src'>Github</a>에 다 올려놓았다.</p><h1 id="day_1">Day 1</h1><p>AOC 2018년 Day1으로 시작. 아주 간단한 로직을 다루고 숫자 관련한 조작을 연습해보는 섹션이 아닌가 싶다.</p><h2 id="%ED%8C%8C%EC%9D%BC_%EC%9D%BD%EA%B3%A0_%ED%8C%8C%EC%8B%B1%ED%95%98%EA%B8%B0">파일 읽고 파싱하기</h2><p>text file을 읽어서 문제를 풀다보니 파일 입출력을 해야했다. line by line으로 읽고 싶었지만 문제의 의도와 거리가 있어서 <code>clojure.core/slurp</code>를 사용했다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;slurp &quot;resources/input.txt&quot;&#41; ; 간단하다
</code></pre><p>아주 간단하다. 읽은 결과는 string이므로 splitting을 잘 해준다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;clojure.string/split #&quot;\n&quot;&#41; ; delimiter는 줄바꿈으로 했다
</code></pre><p>아래와 같은 방식으로 string을 Integer로 파싱할 수 있다. java 라이브러리를 사용하는 것을 확인하면 된다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;Integer/parseInt &quot;+3&quot;&#41;
</code></pre></p><h2 id="part_1">part 1</h2><p>문제는 간단하다. Interger collecitons를 받아서 합을 구하면 된다. <code>apply</code>나 <code>reduce</code>를 이용하면 쉽게 구현할 수 있다.</p><h2 id="part_2">part 2</h2><p>주어진 Integer collections가 무한히 반복된다고 할 때, 같은 누적합이 발견될 때의 누적합을 반환하면 된다.</p><h3 id="%ED%92%80%EC%9D%B4">풀이</h3><p>먼저 <code>repeat</code>을 알고 있었고 collections를 <code>repeat</code>하면 collections of collections이기 때문에 <code>flatten</code>을 사용했었다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn solve-part2 &#91;li&#93;
  &#40;let &#91;inf-seq &#40;flatten &#40;repeat li&#41;&#41;&#93;
    &#40;loop &#91;temp-set #{}
           cur-seq inf-seq
           acc 0&#93;
      &#40;if &#40;temp-set &#40;+ acc &#40;first cur-seq&#41;&#41;&#41;
        &#40;+ acc &#40;first cur-seq&#41;&#41;
        &#40;recur &#40;conj temp-set &#40;+ acc &#40;first cur-seq&#41;&#41;&#41;
               &#40;rest cur-seq&#41;
               &#40;+ acc &#40;first cur-seq&#41;&#41;&#41;&#41;&#41;&#41;&#41;
</code></pre><h3 id="%EB%A6%AC%EB%B7%B0">리뷰</h3><ul><li>flatten + repeat -> cycle로 바꾸면 좋다. (lazy한 특성 때문에 둘 다 사용 가능한 점을 인지하자)</li><li>let을 사용하는게 오히려 안좋지 않을까? 라고 생각했었는데 쓰는게 더 나음</li><li>loop-recur가 clojure에서 좀 쓸만한 녀석인 줄 알고 남발했었는데 anti-pattern이라고 한다. 앞으로는 사용을 자제해보자</li><li>문제의 특성상 같은 누적합이 2번 나오면 그게 정답이다. 누적합은 <code>clojure.core/reductions</code>를 사용하면 쉽게 구할 수 있다.</li><li>docString으로 input, output의 형태나 함수 설명을 해주도록 노력하자.</li></ul><h3 id="reductions%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EB%8D%94_%EB%82%98%EC%9D%80_%EC%BD%94%EB%93%9C">reductions를 이용한 더 나은 코드</h3><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn solve-part2-advanced &#91;li&#93;
  &#40;let &#91;inf-partial-sum li&#93;
    &#40;loop &#91;temp-set #{}
           cur-seq inf-partial-sum&#93;
      &#40;let &#91;sum &#40;first cur-seq&#41;&#93;
        &#40;if &#40;temp-set sum&#41;
          sum
          &#40;recur &#40;conj temp-set sum&#41;
                 &#40;rest cur-seq&#41;&#41;&#41;&#41;&#41;&#41;&#41;

&#40;-&gt;&gt; &quot;resources/input.txt&quot;
      parse-input
      cycle
      &#40;reductions +&#41; ; reductions의 결과인 partial-sum을 파라미터로 넘겼다.
      solve-part2-advanced&#41;
</code></pre><h1 id="day_2">Day 2</h1><p>어제 삽질한 파일 읽는 것 때문에 시간은 잘 벌었다. <code>string</code>을 잘 다루어보는 섹션인 것 같다. 근데 <code>laySeq</code>의 결과를 <code>contains?</code>와 함께 사용할 수 없고 map 데이터구조를 핸들링하는 것에 익숙치 않아서 시간이 오래 걸린 것 같다. 그리고 원래 string 관련 문제는 좀 귀찮은 면은 있는 것 같긴 하다. AOC 2018년 Day 2를 보자.</p><h2 id="part_1">part 1</h2><p>결과부터 말하자면 <code>frequencies + char-array</code>를 사용하면 아주 쉽게 풀리는 문제였는데 저 2가지를 직접 구현하면서 겪은 각종 삽질들 때문에 시간을 많이 잡아 먹었다. 그리고 아래와 같은 코드를 빨리 구현하지 못해서 엄청 헤맸다. 어떻게 삽질 했는지 같이 살펴보자.</p><pre class="language-typescript"><code class="lang-typescript language-typescript">// 조건을 만족할 때만 do sth을 하고 그 조건이 여러개일 때
if &#40;isValid&#40;&#41;&#41; {
    // do sth...
}

if &#40;isValid2&#40;&#41;&#41; {
    // do sth...
}

</code></pre><p>이라는 간단한 걸 구현하고 싶었는데 클로저에서는 이렇게 안된다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;when &#40;isValid&#41; &#40;...&#41;
when &#40;isValid2&#41; &#40;...&#41;&#41; ; 난감했다
</code></pre></p><p>사실 expression자체도 지금 생각하면 안좋다는게 보이지만 아직은 적응이 덜 됐는지 위에 처럼 구현하고 싶은 마음이 처음엔 컸다. 여튼, 그래서 처음에 답은 구했는데 아주 아주 돌아갔다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">; 처음 제출한 답의 메인 로직
&#40;defn calc-freq
  &quot;input: &#91;&#91;1 2 3 4&#93; &#91;2 2 0 0&#93; ...&#93;&quot;
  &#91;li&#93;
  &#40;apply &#42; &#40;reduce &#40;fn &#91;&#91;res1 res2&#93; val&#93;
                     &#40;cond
                       &#40;and &#40;some #&#40;== % 3&#41; val&#41; &#40;some #&#40;== % 2&#41; val&#41;&#41; &#91;&#40;inc res1&#41; &#40;inc res2&#41;&#93;
                       &#40;some #&#40;== % 3&#41; val&#41; &#91;res1 &#40;inc res2&#41;&#93;
                       &#40;some #&#40;== % 2&#41; val&#41; &#91;&#40;inc res1&#41; res2&#93;
                       :else &#91;res1 res2&#93;&#41;&#41; &#91;0 0&#93; li&#41;&#41;&#41;
</code></pre><h2 id="%EB%A6%AC%EB%B7%B0">리뷰</h2><ul><li>reduce는 almighty해서 가급적 안쓰는게 좋다. 쓰더라도 뚱뚱하게 쓰면 안된다.</li><li>고차함수인 map, filter 같은 것만 사용해서 다 구현할 수 있다 (대부분): 이 사실을 명심하자</li><li>contains?는 set에서만 쓰고 map, vector, list에서는 다른 방식으로 contains? 유무를 확인하자</li><li><code>frequencies</code>, <code>char-array</code>를 알자</li></ul><h2 id="%EB%A6%AC%EB%B7%B0_%EB%B0%98%EC%98%81_%ED%9B%84_%EB%8B%A4%EC%8B%9C_%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B8_%EC%BD%94%EB%93%9C">리뷰 반영 후 다시 구현해본 코드</h2><p>이게 베스트인지는 모르겠지만 일단 조금 더 가독성이 높아졌다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn logic-part1 &#91;n str-li&#93;
  &#40;-&gt;&gt; str-li
       &#40;map frequencies&#41;
       &#40;map vals&#41;
       &#40;filter #&#40;some &#40;fn &#91;x&#93; &#40;== x n&#41;&#41; %&#41;&#41;
       count&#41;&#41;

&#40;defn solve-part1 &#91;path&#93;
  &#40;let &#91;res1 &#40;-&gt;&gt; path
                  read-input
                  &#40;logic-part1 2&#41;&#41;
        res2 &#40;-&gt;&gt; path
                  read-input
                  &#40;logic-part1 3&#41;&#41;&#93;
    &#40;&#42; res1 res2&#41;&#41;&#41;
</code></pre></p><h2 id="part_2">part 2</h2><h1 id="day_3">Day 3</h1><p><code>matrix</code>를 다루는 내용이 목적인 것 같다. 2d 리스트나 벡터를 사용하는 것을 다루어보자는 느낌.</p><h2 id="intro">Intro</h2><p>part 1과 part 2가 거의 한번에 풀릴 수 있을 것처럼 보였다. 전체 색칠한 <code>matrix</code>를 만들어내고 이 결과를 가지고 두번 색칠해졌는지 아니면 해당 id가 한번도 덮어씌어진 적 없는지 확인하면 됐었다.</p><h2 id="parsing">parsing</h2><p>input이 좀 괴상하게 들어와서 이것도 연습하는 건가? 싶었다. <code>#1 1,3: 4x4</code> 이런 식으로 인풋이 들어오는데 이걸 잘 파싱해보도록 하자. 위에서 사용한 <code>clojure.string/split</code>과 <code>subs</code>를 요리조리 사용했다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn read-input &#91;path&#93;
  &#40;-&gt; path
      slurp
      &#40;clojure.string/split #&quot;\n&quot;&#41;&#41;&#41;

&#40;defn parse-id
  &quot;input: \&quot;#44\&quot;, output: 44&quot;
  &#91;string&#93;
  &#40;Integer/parseInt &#40;subs string 1 &#40;count string&#41;&#41;&#41;&#41;

&#40;defn parse-pos
  &quot;input: \&quot;1,3:\&quot;, output: &#40;1 3&#41;&quot;
  &#91;string&#93;
  &#40;-&gt;&gt; &#40;clojure.string/split &#40;subs string 0 &#40;dec &#40;count string&#41;&#41;&#41; #&quot;,&quot;&#41;
       &#40;mapv &#40;fn &#91;x&#93; &#40;Integer/parseInt x&#41;&#41;&#41;&#41;&#41;

&#40;defn parse-size
  &quot;input: \&quot;4x4\&quot;, output: &#40;4 4&#41;&quot;
  &#91;string&#93;
  &#40;-&gt;&gt; &#40;clojure.string/split string #&quot;x&quot;&#41;
       &#40;mapv &#40;fn &#91;x&#93; &#40;Integer/parseInt x&#41;&#41;&#41;&#41;&#41;

&#40;defn prepare-data &#91;path&#93;
  &#40;-&gt;&gt; path
       read-input
       &#40;mapv &#40;fn &#91;x&#93; &#40;clojure.string/split x #&quot; &quot;&#41;&#41;&#41;
       &#40;mapv &#40;fn &#91;&#91;id &#95; pos size&#93;&#93;
               &#40;list &#40;parse-id id&#41; &#40;parse-pos pos&#41; &#40;parse-size size&#41;&#41;&#41;&#41;&#41;&#41;
</code></pre><p>id, position, size를 위와 같은 방식으로 파씽했었다.</p><h2 id="part_1">part 1</h2><p>주요 아이디어는 <code>#99 1,3: 2x2</code>라는 인풋이 있을 때 <code>&#40;1 3 99&#41;</code>, <code>&#40;1 4 99&#41;</code>, <code>&#40;2 3 99&#41;</code>, <code>&#40;2 4 99&#41;</code> 의 collections을 가지고 있으면 x, y index에 원하는 id를 갱신하면 된다고 생각했다. 초기값을 다 -1 로 matrix를 만들어 놓았으므로 id가 양수임을 가정했을 때 갱신하려고 할 때 -1이 아니라면 (갱신된 적 있다면) 0으로 갱신해서 (문제에서 X랑 같음) 중복 칠한게 있는지 확인했다. 그리고 마지막으로 0의 갯수를 세어주면서 마무리하였다.</p><p>코드는 아래와 같다.<pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn vec2d
  &quot;2d vectors&quot;
  &#91;sx sy f&#93;
  &#40;mapv &#40;fn &#91;x&#93; &#40;mapv &#40;fn &#91;y&#93; &#40;f x y&#41;&#41; &#40;range sx&#41;&#41;&#41; &#40;range sy&#41;&#41;&#41;

&#40;defn matrix
  &quot;init matrix&quot;
  &#91;&#93;
  &#40;vec2d 2000 2000 &#40;constantly -1&#41;&#41;&#41;

&#40;defn update-cell
  &quot;update cell to id at position &#40;x, y&#41; on matrix&quot;
  &#91;matrix id x y&#93;
  &#40;if &#40;neg? &#40;get-in matrix &#91;x y&#93;&#41;&#41;
    &#40;update-in matrix &#91;x y&#93; &#40;constantly id&#41;&#41;
    &#40;update-in matrix &#91;x y&#93; &#40;constantly 0&#41;&#41;&#41;&#41;

&#40;defn gen-modified-vals
  &quot;output: sequence of &#40;target-x target-y id&#41;&quot;
  &#91;id ix iy sx sy&#93;
  &#40;map &#40;fn &#91;x&#93; &#40;map &#40;fn &#91;y&#93; &#40;list &#40;+ iy x&#41; &#40;+ ix y&#41; id&#41;&#41; &#40;range sx&#41;&#41;&#41; &#40;range sy&#41;&#41;&#41;

&#40;defn flatten-vals
  &quot;flatten and partition 3&quot;
  &#91;values&#93;
  &#40;-&gt;&gt; values
       flatten
       &#40;partition 3&#41;&#41;&#41;

&#40;defn logic-part1
  &quot;update each one&quot;
  &#91;data&#93;
  &#40;reduce &#40;fn &#91;acc &#91;x y id&#93;&#93;
            &#40;update-cell acc id x y&#41;&#41;
          &#40;matrix&#41;                                          ; 초기값
          &#40;flatten-vals &#40;map &#40;fn &#91;&#91;id &#91;ix iy&#93; &#91;sx sy&#93;&#93;&#93;
                               &#40;gen-modified-vals id ix iy sx sy&#41;&#41;
                             data&#41;&#41;&#41;&#41;

&#40;defn solve-part1 &#91;path&#93;
  &#40;-&gt;&gt; path
       prepare-data
       logic-part1
       flatten
       &#40;filter #&#40;zero? %&#41;&#41;
       count&#41;&#41;
</code></pre></p><p>get-in, update-in 같은 nested structure에 사용하는 core 함수를 알게 되었다. 이렇게 푸는게 맞나? 그리고 flatten 왠만해서 안쓰려고 했는데 쓰면 편해서 써버렸다.</p><h2 id="part_2">part 2</h2><p>part 1을 풀어서 쉽게 풀었다. 필터만 잘 하면 된다.</p><pre class="language-clojure"><code class="lang-clojure language-clojure">&#40;defn get-total-count-by-id &#91;path&#93;
  &#40;-&gt;&gt; path
       prepare-data
       &#40;map &#40;fn &#91;&#91;id &#95; &#91;sx sy&#93;&#93;&#93; &#40;list id &#40;&#42; sx sy&#41;&#41;&#41;&#41;&#41;&#41;

&#40;defn logic-part2
  &#91;path data&#93;
  &#40;let &#91;current-id-count &#40;-&gt;&gt; data
                              logic-part1
                              flatten
                              &#40;filter #&#40;pos? %&#41;&#41;
                              frequencies&#41;

        total-count-by-id &#40;get-total-count-by-id path&#41;&#93;
    &#40;-&gt; &#40;filter &#40;fn &#91;&#91;x y&#93;&#93; &#40;== y &#40;get current-id-count x -1&#41;&#41;&#41; total-count-by-id&#41;
        first
        first&#41;&#41;&#41;

&#40;defn solve-part2 &#91;path&#93;
  &#40;-&gt;&gt; path
       prepare-data
       &#40;logic-part2 path&#41;&#41;&#41;
</code></pre><h2 id="%ED%9A%8C%EA%B3%A0">회고</h2><p>언제나 그렇듯 2차 배열을 다루는 문제들은 약간 까다로운 면은 있다. 자주 풀어야 좀 익숙해지는 느낌. 그리고 immutable하게 짠다는게 문제 풀이에서 꽤 까다롭다고 느껴졌다.</p><h2 id="%EB%A6%AC%EB%B7%B0">리뷰</h2><ul><li>전반적으로 naming을 더 신경쓰면 좋을 것 같다는 의견</li><li>naming을 할 때 함수 이름만 보고 뭐하는 건지 알 수 있도록, 함수 이름이 짓기 어렵다고 느꼈다면? 함수로 꼭 만들지 않아도 되는게 아닐까? 라는 생각도 해보자</li><li>matrix 만들 때 2중 map도 좋지만 2중 for를 쓰면 좀 더 나을 수도</li><li>복잡한 parsing을 할 때는 정규식을 쓰는 것도 방법 (항상 좋은 것은 아니지만 경우에 따라)</li><li><code>vector</code>는 random access가 필요할 때 쓰긴 하지만 <code>list</code>보다는 <code>vector</code>를 주로 사용해도 좋음</li><li>그리고 <code>vector</code>나 <code>list</code>를 사용하더라도 순서에 따른 context가 있는 경우에는 <code>hash-map</code>을 쓰는게 훨씬 좋음</li><li>matrix 초기활 때 사용한 -1, 0 같은 값들은 keyword로 관리하는 것이 좋음</li><li><code>==</code>와 <code>=</code> 차이: <code>==</code>는 타입은 신경 쓰지 않고 값만 비교, <code>=</code>는 타입과 값 모두 비교</li><li>ex. <code>&#40;= 0.2 1/5&#41; ; false &#40;== 0.2 1/5&#41; ; true</code></li><li>관용적으로... <code>-&gt;</code>의 경우 hash-map이나 string에 쓰고 <code>-&gt;&gt;</code> seq를 다룰 때 많이 씀 (생각해보기)</li><li><code>first + first</code> 는 <code>ffirst</code>로</li></ul><h2 id="%EB%A6%AC%EB%B7%B0_%EB%B0%98%EC%98%81_%ED%9B%84_%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9D%B8_%EC%BD%94%EB%93%9C">리뷰 반영 후 전체적인 코드</h2><p>길이가 길어서 링크로 대체한다. 2중 for 문이 2d 다루는데 꽤나 편리한 것 같아서 유용했고 javascript의 object처럼 hash-map을 주요하게 사용하니 편했다. 이게 ps에서는 혼자 빨리 푸는게 중요해서 신경 안썼는데 부트캠프이니만큼 가독성도 신경 써야겠다.<h2></h2><h1 id="%EC%89%AC%EC%96%B4%EA%B0%80%EA%B8%B0">쉬어가기</h1>3일정도 리뷰해보니 코드를 대충 어떻게 작성해야하는지 약간 감은 왔다. 물론 뒤에도 더 많은 리뷰가 있겠지만 뒷 부분에는 코드는 <a href='ttps://github.com/jungwookim/aoc-exercise/tree/master/src'>github 링크</a>로 대체하고 내용 위주로 살펴보자.<h2></h2><h1 id="day_4">Day 4</h1>AOC 2018 Day 4. datetime을 parsing해서 사용하고 싶지만 그렇게 풀지 않아도 되는 문제. 문제의 요구사항을 잘 읽어보면 <code>00:00&#126;00:59</code> 사이의 데이터만 있는 것을 알 수 있음. input이 까다로워서 데이터 전처리하는데 드는 시간이 더 많았던 것 같다. 앞선 리뷰들을 잘 반영해서 <code>hash-map</code> 적절히 잘 사용했음.</p><ul><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day4.clj'>내가 푼 코드</a></li><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day4_reviewed.clj'>리뷰 받은 코드</a></li></ul><h2 id="%EC%A3%BC%EC%9A%94_%EB%82%B4%EC%9A%A9">주요 내용</h2><ul><li><code>map + flatten</code> 같은 건 <code>mapcat</code>을 사용해도 좋다.</li><li><code>assoc-in + get-in</code> 대신 <code>update-in</code>이라는 걸 쓰자</li><li><code>map</code>을 부분적으로 바꿀 때는 <code>update</code> 혹은 <code>update-in</code>을 쓰자</li><li><code>hash-map desctructing</code>은 같은 이름을 사용할거라면 <code>{:keys &#91;…&#93;}</code>를 사용해도 좋다.</li><li><code>max-key</code>라는 좋은게 있더라</li></ul><h1 id="day_5">Day 5</h1><p>AOC 2018 Day 5. 대소문자 잘 구분하는 문제. 어렵진 않았음.</p><ul><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day5.clj'>내가 푼 코드</a></li><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day5_reviewed.clj'>리뷰 받은 코드</a></li></ul><p>특별한 내용은 없었던 것 같다.</p><h1 id="day_6">Day 6</h1><p>AOC 2018 Day 6. 문제 접근법 자체가 약간 어려웠던 문제. 실제 코드로 구현하는데도 시간이 많이 걸렸음.</p><ul><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day6.clj'>내가 푼 코드</a></li><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day6_reviewed.clj'>리뷰 받은 코드</a></li></ul><h2 id="%EC%A3%BC%EC%9A%94_%EB%82%B4%EC%9A%A9">주요 내용</h2><ul><li>return type의 일관성을 가지면 좋다.</li><li><code>group-by</code>라는 것이 있다.</li><li>aggregation할 때 <code>frequencies</code>를 잘 사용해도 좋다.</li></ul><h1 id="day_7">Day 7</h1><p>AOC 2018 Day 7. workers들의 일을 잘 할당하는 문제.</p><ul><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day7.clj'>내가 푼 코드</a></li><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day7_reviewed.clj'>리뷰 받은 코드</a></li></ul><h2 id="%EC%A3%BC%EC%9A%94_%EB%82%B4%EC%9A%A9">주요 내용</h2><ul><li><code>iterate</code> + <code>drop-while</code>을 잘 쓰면 좋다</li><li>^ 이거 쓸 때 주의해야하는 점들이 몇가지 있는데 일단 <code>LazySeq</code>를 반환하기 때문에 이게 가능한 것을 꼭 인지하고 써야한다. 그렇기 때문에 <code>take</code>, <code>first</code> 등 을 하지 않으면 drop-while의 결과가 무한하기 때문에 <code>first</code>, <code>take</code> 등을 같이 꼭 사용하도록 하자.</li><li>사용법이라기 보다는 이 개념을 인지하고 있자.</li><li>상태라는 걸 잘 관리한다는 측면에서 생각하자</li><li>이 문제는 클로저랑 상관 없이 ps적으로 봐도 좋은 문제인 것 같다</li><li><code>threading-macro</code>는 함수의 조합으로 절차지향적으로 생각할 수 있게 하는 좋은 도구인 것 같다</li><li>그럼에도 불구하고 디버깅에 많은 시간을 썼는데 반성하도록 하자</li></ul><h1 id="day_8">Day 8</h1><p>AOC 2020 Day 1, 4. 간단한 두 문제였다. 생각해보면 첫 날에 풀었다면 조금 헤맸을 수도 있지만 부트캠프 8일차에 풀기엔 쉬웠던 문제.</p><ul><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2018_day8.clj'>내가 푼 코드</a></li></ul><h2 id="%EC%A3%BC%EC%9A%94_%EB%82%B4%EC%9A%A9">주요 내용</h2><ul><li>Day 7에서 얻은 지식들 덕분에 쉽게 푼 것 같다.</li><li><code>map-indexed</code>는 처음 써봤다.</li><li><code>drop-while</code> 멈추는 조건이 할 때마다 약간 헷갈린다.</li></ul><h2 id="%EC%BD%94%EB%93%9C">코드</h2><ul><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2020_day1.clj'>2020-day1</a></li><li><a href='https://github.com/jungwookim/aoc-exercise/blob/master/src/p2020_day4.clj'>2020-day4</a></li></ul><h2 id="%ED%9A%8C%EA%B3%A0">회고</h2><ul><li><code>for</code>를 사용하면 combination처럼 2중 루프를 돌게 되는데 이 때 break-point로 <code>:when</code> 같은 걸 사용할 수 있더라.</li><li>두번째 문제는 파싱만 잘하면 되는 문제였다. 다만 정규식에 익숙하지 않아 항상 불편한 점은 있다.</li><li><code>clojure.spec</code> 이라는 걸 활용해보자</li></ul><h1 id="reference">Reference</h1><ul><li><a href='ttps://github.com/jungwookim/aoc-exercise/tree/master/src'>my github repo</a></li><li><a href='ttps://clojuredocs.org/clojure.core'>clojure library documents</a></li><li><a href='ttps://adventofcode.com/2018/day/3'>advent of code</a></li></ul>]]></content>
  </entry>
</feed>
